# Основы оркестрации контейнеров

Использование инструментов docker compose и docker swarm для совместного запуска контейнеров и их простейшей оркестрации.

## Contents

1. [Chapter I](#chapter-i)
2. [Chapter II](#chapter-ii) \
   2.1. [Запуск нескольких docker-контейнеров с использованием docker compose](#part-1-запуск-нескольких-docker-контейнеров-с-использованием-docker-compose) \
   2.2. [Создание виртуальной машины](#part-2-создание-виртуальных-машин) \
   2.3. [Создание простейшего docker swarm](#part-3-создание-простейшего-docker-swarm)

## Chapter I

Как тебе уже известно, **docker** — это платформа для сборки, запуска и *доставки* приложений, призванная выполнять программное обеспечение практически вне зависимости от машины, на которой она будет физически исполняться. Этот эффект достигается путем *контейнеризации* ПО, то есть помещения исполняемого ПО в отдельную подсреду — *контейнер*, содержащую в себе все необходимые зависимости и, если образ контейнера составлен хорошо, больше ничего лишнего. На самом деле, проблема зависимостей является намного более серьезной, чем может показаться с первого взгляда. Слабыми местами здесь являются не только недостающие файлы или библиотеки, а возможно, версии библиотек или даже языка, значения переменных окружения и многие другие аспекты, которые могут, если и не сломать ПО окончательно, но значительно повлиять на его работоспособность. Контейнер гарантирует *одинаковое* выполнение контейнеризируемого ПО на любых машинах, так как содержит в себе все необходимое для последовательной работы находящегося внутри ПО. Этот аспект является особенно важным при разработке веб-сервисов, где возможны частые обновления ПО и переразмещение на разных машинах.

Обычно серьезное приложение состоит не из одной программы, то есть имеет не монолитную структуру, а микросервисную. Конечно, чисто формально, каждый сервис может быть развернут в одном и том же контейнере, но данный подход не соответствует принципам SOLID и чистой архитектуры в целом. Например, при таком подходе практически невозможно или значительно усложняется процесс развертывания новой версии отдельного микросервиса. Обязательно следует запомнить основное правило контейнеризации: «1 микросервис — 1 контейнер». 

Теперь, когда правило насчет распределения микросервисов по контейнерам определено, стоит вспомнить еще об одном инструменте — **docker compose**, позволяющий запускать сразу несколько контейнеров вместе. **Docker compose** не только позволяет запускать несколько docker-контейнеров одновременно, но и предоставляет возможность определения их взаимодействия, что является необходимым условием для развертывания микросервисного приложения.

Однако один лишь **docker compose** позволяет запустить контейнеры только на одной машине. В реальности же микросервисные приложения распределены по различным машинам: реальным или виртуальным значения не имеет. Обычно, конечно, это оказываются виртуальные машины, но далеко не обязательно, что все используемые одним программным обеспечением виртуальные машины находятся на одной и той же реальной. Зачастую это даже совсем не так. Здесь и появляется **docker swarm**. Вообще, словосочетание **docker swarm** означает как и просто группу машин, объединенных в один *кластер*, с запущенными на них связанными между собой docker-контейнерами, так и инструмент, который объединяет машины в такой *кластер*. *Кластер* — это объединение машин, или *узлов* (nodes), в единую сеть с распределенной по этим узлам нагрузкой в виде исполняемых в контейнерах приложениях. За запуск и курирование такого кластера отвечают специальные программы, называемые оркестраторами. **Docker swarm** как раз является одной из них. **Docker swarm** это относительно простой и легкий в освоении оркестратор, обладающий всеми базовыми инструментами.

Наконец, откуда же взять машины, которые будут взяты за основу для узлов кластера? Ответ: виртуализация. Одним из наиболее популярных и простых инструментов создания виртуальных машин является **vagrant**. **Vagrant** позволяет быстро, всего парой команд, создать несколько небольших виртуальных машин.

## Chapter II

Итогом выполненной работы должен быть отчет с подробными описаниями выполнения каждого из пунктов, подкрепленного скриншотами. Отчет формируется в виде markdown файла в директории `src` с именем `REPORT.MD`

## Part 1. Запуск нескольких docker-контейнеров с использованием docker compose

Стоит вспомнить, как работает docker-compose! Сначала давай попробуем запустить микросервисное приложение из папки `src` таким образом, чтобы тесты постмана проходили успешно.

**== Задание ==**

1) Напиши Dockerfile для каждого отдельного микросервиса. В отчете отобрази размер собранных образов любого сервиса различными способами.

2) Напиши docker-compose файл, который осуществляет корректное взаимодействие сервисов. Пробрось порты для доступа к gateway service и session service из локальной машины.

3) Собери и разверни веб-сервис с помощью написанного docker compose файла на локальной машине.

4) Прогони заготовленные тесты через postman и удостоверься, что все они проходят успешно. В отчете отобрази результаты тестирования.

## Part 2. Создание виртуальных машин

Пришло время заготовить основу для будущих узлов кластера. Создадим виртуальную машину.

**== Задание ==**

1) Установи и инициализируй Vagrant в корне проекта. Напиши Vagrantfile для одной виртуальной машины. Перенеси в виртуальную машину исходный код веб-сервиса в рабочую директорию виртуальной машины.

2) Зайди через консоль внутрь виртуальной машины и удостоверься, что исходный код встал, куда нужно. Останови и уничтожь виртуальную машину.

## Part 3. Создание простейшего docker swarm

Ну вот и пришло время создания твоего первого docker swarm!

**== Задание ==**

1) Модифицируй Vagrantfile для создания трех машин: manager01, worker01, worker02. Напиши shell-скрипты для установки docker внутрь машин, инициализации и подключения к docker swarm.

2) Загрузи собранные образы на docker hub и модифицировать docker-compose файл для подгрузки расположенных на docker hub образов.

3) Подними виртуальные машины и перенести на менеджер docker-compose файл. Запусти стек сервисов, используя написанный docker-compose файл.

4) Настрой прокси на базе nginx для доступа к gateway service и session service по оверлейной сети. Сами gateway service и session service сделай недоступными напрямую.

5) Прогони заготовленные тесты через postman и удостоверься, что все они проходят успешно. В отчете отобрази результаты тестирования.

6) Используя команды docker, отобрази в отчете распределение контейнеров по узлам.

7) Установи отдельным стеком Portainer внутри кластера. В отчете отобрази визуализацию распределения задач по узлам с помощью Portainer.
